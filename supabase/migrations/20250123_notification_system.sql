-- Notification System Migration
-- Created: 2025-01-23
-- This migration creates the complete notification system with three distinct notification types

-- Enable necessary extensions
CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- ============================================================================
-- 1. NOTIFICATION SYSTEM CORE
-- ============================================================================

-- 1.1 Enum + notifications table
DO $$
BEGIN
  IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'notification_type') THEN
    CREATE TYPE notification_type AS ENUM ('message', 'request', 'car_activity');
  END IF;
END$$;

CREATE TABLE IF NOT EXISTS public.notifications (
  id           BIGINT GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  user_id      UUID NOT NULL,                          -- who should see it
  type         notification_type NOT NULL,
  title        TEXT NOT NULL,
  body         TEXT,
  payload      JSONB,                                  -- { vin, request_id, message_id, route, ... }
  is_read      BOOLEAN DEFAULT FALSE,
  created_at   TIMESTAMPTZ DEFAULT now()
);

CREATE INDEX IF NOT EXISTS idx_notifications_user ON public.notifications (user_id, is_read, type, created_at DESC);

-- 1.2 Unread counters view (fast badges)
CREATE OR REPLACE VIEW public.notifications_unread_counts AS
SELECT
  user_id,
  type,
  COUNT(*)::int AS unread_count
FROM public.notifications
WHERE is_read = FALSE
GROUP BY user_id, type;

-- 1.3 RLS (example)
ALTER TABLE public.notifications ENABLE ROW LEVEL SECURITY;
ALTER TABLE public.notifications FORCE ROW LEVEL SECURITY;

-- Everyone can read their own notifications
CREATE POLICY notifications_select ON public.notifications
  FOR SELECT TO authenticated
  USING (auth.uid() = user_id);

-- Insert by server/service role or allowed functions
CREATE POLICY notifications_insert ON public.notifications
  FOR INSERT TO authenticated
  WITH CHECK (auth.uid() = user_id);

-- Mark-as-read by the receiver
CREATE POLICY notifications_update ON public.notifications
  FOR UPDATE TO authenticated
  USING (auth.uid() = user_id)
  WITH CHECK (auth.uid() = user_id);

-- 1.4 Helper RPCs
-- Mark a batch as read by type
CREATE OR REPLACE FUNCTION public.mark_notifications_read(p_type notification_type)
RETURNS void
LANGUAGE sql SECURITY DEFINER AS $$
  UPDATE public.notifications
     SET is_read = TRUE
   WHERE user_id = auth.uid()
     AND type = p_type
     AND is_read = FALSE;
$$;

GRANT EXECUTE ON FUNCTION public.mark_notifications_read(notification_type) TO authenticated;

-- ============================================================================
-- 2. EVENT→NOTIFICATION TRIGGERS
-- ============================================================================

-- 2.1 Messages → "message" notification
-- Hook into your existing messages table
CREATE OR REPLACE FUNCTION public.notify_on_message()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER AS $$
BEGIN
  INSERT INTO public.notifications (user_id, type, title, body, payload)
  VALUES (
    NEW.recipient_id, -- Adjust based on your messages table structure
    'message',
    'New message',
    LEFT(NEW.message_text, 120),
    jsonb_build_object('message_id', NEW.id, 'route', '/messages')
  );
  RETURN NEW;
END$$;

-- Create trigger on your messages table (adjust table name as needed)
-- DROP TRIGGER IF EXISTS trg_notify_on_message ON public.messages;
-- CREATE TRIGGER trg_notify_on_message
-- AFTER INSERT ON public.messages
-- FOR EACH ROW EXECUTE FUNCTION public.notify_on_message();

-- 2.2 Requests → "request" notification
-- Hook into your existing requests table
CREATE OR REPLACE FUNCTION public.notify_on_request()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE _target uuid;
BEGIN
  _target := NEW.assigned_to;  -- or your routing logic (owner/assistant/etc.)
  IF _target IS NOT NULL THEN
    INSERT INTO public.notifications (user_id, type, title, body, payload)
    VALUES (
      _target,
      'request',
      coalesce(NEW.title, 'New Request'),
      concat('Status: ', NEW.status),
      jsonb_build_object('request_id', NEW.id, 'route', '/requests')
    );
  END IF;
  RETURN NEW;
END$$;

-- Create trigger on your requests table (adjust table name as needed)
-- DROP TRIGGER IF EXISTS trg_notify_on_request ON public.requests;
-- CREATE TRIGGER trg_notify_on_request
-- AFTER INSERT OR UPDATE ON public.requests
-- FOR EACH ROW EXECUTE FUNCTION public.notify_on_request();

-- 2.3 Car activity → "car_activity" notification
-- Hook into test drives, garage schedule, moves

-- Test drives notification
CREATE OR REPLACE FUNCTION public.notify_on_test_drive()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE _title text; _vin text;
BEGIN
  -- Get VIN from car_inventory
  SELECT vin INTO _vin FROM public.car_inventory WHERE id = NEW.car_id;
  
  IF NEW.status = 'started' THEN
    _title := concat('Test Drive STARTED (', COALESCE(_vin, 'Unknown VIN'), ')');
  ELSIF NEW.status = 'ended' THEN
    _title := concat('Test Drive ENDED (', COALESCE(_vin, 'Unknown VIN'), ')');
  ELSE
    _title := concat('Test Drive ', upper(NEW.status), ' (', COALESCE(_vin, 'Unknown VIN'), ')');
  END IF;

  -- Send to Owners + Garage Manager (adjust role mapping as needed)
  INSERT INTO public.notifications (user_id, type, title, body, payload)
  SELECT u.id, 'car_activity', _title,
         to_char(now(), 'DD Mon HH24:MI'),
         jsonb_build_object('vin', _vin, 'test_drive_id', NEW.id, 'route', '/garage/test-drives')
  FROM public.user_profiles u
  WHERE u.role IN ('OWNER','GARAGE_MANAGER') OR u.role = 'admin';

  RETURN NEW;
END$$;

-- Create trigger on test_drives table
DROP TRIGGER IF EXISTS trg_notify_on_test_drive ON public.test_drives;
CREATE TRIGGER trg_notify_on_test_drive
AFTER INSERT OR UPDATE OF status ON public.test_drives
FOR EACH ROW EXECUTE FUNCTION public.notify_on_test_drive();

-- Garage schedule notification
CREATE OR REPLACE FUNCTION public.notify_on_garage()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE _title text; _vin text;
BEGIN
  -- Get VIN from car_inventory
  SELECT vin INTO _vin FROM public.car_inventory WHERE id = NEW.car_id;
  
  _title := concat('Garage ', upper(NEW.status), ' (', COALESCE(_vin, 'Unknown VIN'), ')');
  
  INSERT INTO public.notifications (user_id, type, title, body, payload)
  SELECT u.id, 'car_activity', _title,
         to_char(now(), 'DD Mon HH24:MI'),
         jsonb_build_object('vin', _vin, 'schedule_id', NEW.id, 'route', '/garage/schedule')
  FROM public.user_profiles u
  WHERE u.role IN ('OWNER','GARAGE_MANAGER') OR u.role = 'admin';
  
  RETURN NEW;
END$$;

-- Create trigger on garage_schedule table
DROP TRIGGER IF EXISTS trg_notify_on_garage ON public.garage_schedule;
CREATE TRIGGER trg_notify_on_garage
AFTER INSERT OR UPDATE OF status ON public.garage_schedule
FOR EACH ROW EXECUTE FUNCTION public.notify_on_garage();

-- Car move notification (hook into your car movement system)
CREATE OR REPLACE FUNCTION public.notify_on_car_move()
RETURNS TRIGGER LANGUAGE plpgsql SECURITY DEFINER AS $$
DECLARE _title text;
BEGIN
  IF OLD.current_location IS DISTINCT FROM NEW.current_location THEN
    _title := concat('Car moved to ', NEW.current_location, ' (', NEW.vin, ')');
    
    INSERT INTO public.notifications (user_id, type, title, body, payload)
    SELECT u.id, 'car_activity', _title,
           to_char(now(), 'DD Mon HH24:MI'),
           jsonb_build_object('vin', NEW.vin, 'route', '/car-inventory?vin='||NEW.vin)
    FROM public.user_profiles u
    WHERE u.role IN ('OWNER','GARAGE_MANAGER') OR u.role = 'admin';
  END IF;
  
  RETURN NEW;
END$$;

-- Create trigger on car_inventory table for location changes
DROP TRIGGER IF EXISTS trg_notify_on_car_move ON public.car_inventory;
CREATE TRIGGER trg_notify_on_car_move
AFTER UPDATE OF current_location ON public.car_inventory
FOR EACH ROW EXECUTE FUNCTION public.notify_on_car_move();

-- ============================================================================
-- 3. SAMPLE DATA FOR TESTING
-- ============================================================================

-- Insert sample notifications for testing (remove in production)
-- INSERT INTO public.notifications (user_id, type, title, body, payload) VALUES
--   ('your-user-id', 'message', 'Welcome to Monza TECH', 'Your account has been activated', '{"route": "/dashboard"}'),
--   ('your-user-id', 'request', 'New PDI Request', 'Status: open', '{"request_id": "sample-id", "route": "/requests"}'),
--   ('your-user-id', 'car_activity', 'Test Drive Started (ABC123)', '12 Jan 14:30', '{"vin": "ABC123", "route": "/garage/test-drives"}');

-- ============================================================================
-- 4. MIGRATION COMPLETION
-- ============================================================================

COMMENT ON TABLE public.notifications IS 'Central notification system for messages, requests, and car activity';
COMMENT ON VIEW public.notifications_unread_counts IS 'Fast unread count view for notification badges';
COMMENT ON FUNCTION public.mark_notifications_read(notification_type) IS 'Mark all notifications of a type as read for the current user';

-- Log migration completion
DO $$
BEGIN
  RAISE NOTICE 'Notification system migration completed successfully!';
  RAISE NOTICE 'Created: notifications table, unread counts view, triggers, and RPC functions';
  RAISE NOTICE 'Next: Update your frontend to use the InstallAndNotifsCluster component';
END $$;
